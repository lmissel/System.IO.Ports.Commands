#
# Module Name: System.IO.MemoryMappedFiles.Commands
# Module Guid: db8afca9-9484-4212-bc58-0989c2050b39
#
# Generated by: lmissel
#
# Generated on: 7/13/2021
#

$Script:LocalizedData = Import-LocalizedData

function Get-SerialPort
{
	[CmdletBinding(DefaultParameterSetName = 'Default',
					SupportsShouldProcess,
					PositionalBinding = $false,
					HelpUri = 'https://github.com/lmissel/System.IO.Ports.Commands',
					ConfirmImpact = 'Medium')]
	[OutputType([PSObject[]])]
	Param
	(
		[ValidateNotNullOrEmpty()]
		[Switch] $ListAvailable
	)

	Begin
	{
		Write-Verbose -Message ('[{0}] Function started' -f $MyInvocation.MyCommand.Name)
		Write-Verbose -Message ('[{0}] ParameterSetName: {1}' -f $MyInvocation.MyCommand.Name, $PsCmdlet.ParameterSetName)
		Write-Verbose -Message ('[{0}] PSBoundParameters: {1}' -f $MyInvocation.MyCommand.Name, ($PSBoundParameters | Out-String))
	}
	Process
	{
		if ($PsCmdlet.ShouldProcess('SerialPort', $MyInvocation.MyCommand.Name))
		{
			try
			{
				$SerialPortNameCollection = @()

				foreach ($portName in ([IO.Ports.SerialPort]::getportnames()))
				{
					$SerialPortName = New-Object -TypeName PSObject
					$SerialPortName | Add-Member -MemberType NoteProperty -Name portName -Value $portName

					$SerialPortNameCollection += $SerialPortName
				}

				return $SerialPortNameCollection
			}
			catch [ComponentModel.Win32Exception]
			{
				Write-Error -Message $Script:LocalizedData.Win32Exception
			}
			catch
			{
				Write-Error -Message $_
			}
		}
	}
	End
	{
			Write-Verbose -Message ('[{0}] Function Ended' -f $MyInvocation.MyCommand.Name)
	}
	
	# .ExternalHelp System.IO.Ports.Commands-help.xml
}

function Open-SerialPort
{
	[CmdletBinding(DefaultParameterSetName = 'Default',
					SupportsShouldProcess,
					PositionalBinding = $false,
					HelpUri = 'https://github.com/lmissel/System.IO.Ports.Commands',
					ConfirmImpact = 'Medium')]
	[OutputType([IO.Ports.SerialPort])]
	Param
	(
		[Parameter(Mandatory,
					HelpMessage='The port to use (for example, COM1).',
					ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 0)]
		[ValidateNotNullOrEmpty()]
		[String] $portName,

		[Parameter(ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 1)]
		[ValidateNotNullOrEmpty()]
		[ValidateRange(1,[int]::MaxValue)]
		[int] $baudRate = 9600,

		[Parameter(ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 2)]
		[ValidateNotNullOrEmpty()]
		[IO.Ports.Parity] $parity = [IO.Ports.Parity]::None,

		[Parameter(ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 3)]
		[ValidateNotNullOrEmpty()]
		[ValidateRange(5,8)]
		[int] $dataBits = 8,

		[Parameter(ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 4)]
		[ValidateNotNullOrEmpty()]
		[IO.Ports.StopBits] $stopBits = [IO.Ports.StopBits]::One,

		[Parameter(ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 5)]
		[ValidateNotNullOrEmpty()]
		[IO.Ports.Handshake]$Handshake = [IO.Ports.Handshake]'None'
	)

	Begin
	{
		Write-Verbose -Message ('[{0}] Function started' -f $MyInvocation.MyCommand.Name)
		Write-Verbose -Message ('[{0}] ParameterSetName: {1}' -f $MyInvocation.MyCommand.Name, $PsCmdlet.ParameterSetName)
		Write-Verbose -Message ('[{0}] PSBoundParameters: {1}' -f $MyInvocation.MyCommand.Name, ($PSBoundParameters | Out-String))
	}
	Process
	{
		if ($PsCmdlet.ShouldProcess($portName, $MyInvocation.MyCommand.Name))
		{
			try
			{
				[IO.Ports.SerialPort] $SerialPort = [IO.Ports.SerialPort]::new($portName, $baudRate, $parity, $dataBits, $stopBits)
				$SerialPort.Handshake = $Handshake

				$SerialPort.open()

				Start-Sleep -Milliseconds 1000

				if ($SerialPort.IsOpen)
				{
					$SI1 = 'SerialDataReceivedEventHandler' + $SerialPort.PortName
					$SI2 = 'SerialErrorReceivedEventHandler' + $SerialPort.PortName
					$SI3 = 'SerialPinChangedEventHandler' + $SerialPort.PortName

					Write-Verbose -Message ('Register EventHandler [DataReceived] for [{0}]' -f $SerialPort.PortName)
					Register-ObjectEvent -InputObject $SerialPort -EventName DataReceived -SourceIdentifier $SI1

					Write-Verbose -Message ('Register EventHandler [Disposed] for [{0}]' -f $SerialPort.PortName)
					Register-ObjectEvent -InputObject $SerialPort -EventName Disposed -SourceIdentifier $SerialPort.PortName

					Write-Verbose -Message ('Register EventHandler [ErrorReceived] for [{0}]' -f $SerialPort.PortName)
					Register-ObjectEvent -InputObject $SerialPort -EventName ErrorReceived -SourceIdentifier $SI2

					Write-Verbose -Message ('Register EventHandler [PinChanged] for [{0}]' -f $SerialPort.PortName)
					Register-ObjectEvent -InputObject $SerialPort -EventName PinChanged -SourceIdentifier $SI3
				}
				return $SerialPort
			}
			catch [IO.IOException]
			{
				Write-Error -Message $Script:LocalizedData.IOException
			}
			catch
			{
				Write-Error -Message $_
			}
		}
	}
	End
	{
		Write-Verbose -Message ('[{0}] Function Ended' -f $MyInvocation.MyCommand.Name)
	}
	# .ExternalHelp System.IO.Ports.Commands-help.xml
}

function Close-SerialPort
{
	[CmdletBinding(DefaultParameterSetName = 'Default',
					SupportsShouldProcess,
					PositionalBinding = $false,
					HelpUri = 'https://github.com/lmissel/System.IO.Ports.Commands',
					ConfirmImpact = 'Medium')]
	Param
	(
		[Parameter(Mandatory,
					HelpMessage='Represents a serial port resource.',
					ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 0)]
		[Alias('SerialPort')]
		[IO.Ports.SerialPort] $InputObject
	)

	Begin
	{
		Write-Verbose -Message ('[{0}] Function started' -f $MyInvocation.MyCommand.Name)
		Write-Verbose -Message ('[{0}] ParameterSetName: {1}' -f $MyInvocation.MyCommand.Name, $PsCmdlet.ParameterSetName)
		Write-Verbose -Message ('[{0}] PSBoundParameters: {1}' -f $MyInvocation.MyCommand.Name, ($PSBoundParameters | Out-String))
	}
	Process
	{
		if ($PsCmdlet.ShouldProcess($InputObject.PortName, $MyInvocation.MyCommand.Name))
		{
			# Checks if an instance of the SerialPort class is present
			if ($InputObject)
			{
				try
				{
					# Cancels an event subscription.
					$SI1 = 'SerialDataReceivedEventHandler' + $InputObject.PortName
					$SI2 = 'SerialErrorReceivedEventHandler' + $InputObject.PortName
					$SI3 = 'SerialPinChangedEventHandler' + $InputObject.PortName

					Unregister-Event -SourceIdentifier $SI1
					Unregister-Event -SourceIdentifier $SI2
					Unregister-Event -SourceIdentifier $SI3
					Unregister-Event -SourceIdentifier $InputObject.PortName
					Write-Verbose -Message ('EventSubscription for [{0}] are unregistered.' -f $InputObject.PortName)

					# Closes the port connection, sets the IsOpen property to false and deletes the internal stream object.
					Write-Verbose -Message ('Closing SerialPort [{0}].' -f $InputObject.PortName)
					$InputObject.Close()

					# Releases the unmanaged resources used by SerialPort and optionally the managed resources.
					$InputObject.Dispose()
				}
				catch
				{
					Write-Error -Message $_
				}
			}
		}
	}
	End
	{
		Write-Verbose -Message ('[{0}] Function Ended' -f $MyInvocation.MyCommand.Name)
	}
	# .ExternalHelp System.IO.Ports.Commands-help.xml
}

function Write-SerialPort
{
	[CmdletBinding(DefaultParameterSetName = 'Default',
					SupportsShouldProcess,
					PositionalBinding = $false,
					HelpUri = 'https://github.com/lmissel/System.IO.Ports.Commands',
					ConfirmImpact = 'Medium')]
	Param
	(
		[Parameter(Mandatory,
					HelpMessage='Represents a serial port resource.',
					ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 0,
					ParameterSetName = 'Default')]
		[Parameter(Mandatory,
					HelpMessage='Represents a serial port resource.',
					ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 0,
					ParameterSetName = 'Write(Byte[], Int32, Int32)')]
		[ValidateNotNull()]
		[ValidateNotNullOrEmpty()]
		[Alias('SerialPort')]
		[IO.Ports.SerialPort] $InputObject,

		[Parameter(Mandatory,
					HelpMessage='Writes the specified string to the serial port.',
					ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 1,
					ParameterSetName = 'Default')]
		[ValidateNotNull()]
		[ValidateNotNullOrEmpty()]
		[String] $Text,

		[Parameter(Mandatory,
					HelpMessage='he byte array that contains the data to write to the port.',
					ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 1,
					ParameterSetName = 'Write(Byte[], Int32, Int32)')]
		[ValidateNotNull()]
		[ValidateNotNullOrEmpty()]
		[byte[]] $Byte,

		[Parameter(ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 1,
					ParameterSetName = 'Write(Byte[], Int32, Int32)')]
		[ValidateNotNull()]
		[ValidateNotNullOrEmpty()]
		[int] $Offset = 0,

		[Parameter(ValueFromRemainingArguments = $false,
					Position = 2,
					ParameterSetName = 'Default')]
		[Switch] $NoNewline
	)

	Begin
	{
		Write-Verbose -Message ('[{0}] Function started' -f $MyInvocation.MyCommand.Name)
		Write-Verbose -Message ('[{0}] ParameterSetName: {1}' -f $MyInvocation.MyCommand.Name, $PsCmdlet.ParameterSetName)
		Write-Verbose -Message ('[{0}] PSBoundParameters: {1}' -f $MyInvocation.MyCommand.Name, ($PSBoundParameters | Out-String))
	}
	Process
	{
		if ($PsCmdlet.ShouldProcess($InputObject.PortName, $MyInvocation.MyCommand.Name))
		{
			try
			{
				if ($PsCmdlet.ParameterSetName -eq 'Default')
				{
					if ($NoNewline)
					{
						# Writes the specified string to the serial port.
						$InputObject.Write($Text)
					}
					else
					{
						# Writes the specified string and NewLine value to the output buffer.
						$InputObject.WriteLine($Text)
					}
				}

				if ($PsCmdlet.ParameterSetName -eq 'Write(Byte[], Int32, Int32)')
				{
					$InputObject.Write($Byte, $Offset, $Byte.Length)
				}
			}
			catch [TimeoutException]
			{
				Write-Error -Message $Script:LocalizedData.TimeoutException
			}
			catch [InvalidOperationException]
			{
				Write-Error -Message $Script:LocalizedData.InvalidOperationException
			}
			catch [ArgumentNullException]
			{
				Write-Error -Message $Script:LocalizedData.ArgumentNullException
			}
			catch [ArgumentOutOfRangeException]
			{
				Write-Error -Message $Script:LocalizedData.ArgumentOutOfRangeException
			}
			catch [ArgumentException]
			{
				Write-Error -Message $Script:LocalizedData.ArgumentException
			}
			catch
			{
				Write-Error -Message $_
			}
		}
	}
	End
	{
		Write-Verbose -Message ('[{0}] Function Ended' -f $MyInvocation.MyCommand.Name)
	}
	# .ExternalHelp System.IO.Ports.Commands-help.xml
}

function Read-SerialPort
{
	[CmdletBinding(DefaultParameterSetName = 'Default',
					SupportsShouldProcess,
					PositionalBinding = $false,
					HelpUri = 'https://github.com/lmissel/System.IO.Ports.Commands',
					ConfirmImpact = 'Medium')]
	Param
	(
		[Parameter(Mandatory,
					HelpMessage='Represents a serial port resource.',
					ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 0,
					ParameterSetName = 'Default')]
		[Parameter(Mandatory,
					HelpMessage='Represents a serial port resource.',
					ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 0,
					ParameterSetName = 'ReadExistingSet')]
		[Parameter(Mandatory,
					HelpMessage='Represents a serial port resource.',
					ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 0,
					ParameterSetName = 'ReadSet')]
		[Alias('SerialPort')]
		[IO.Ports.SerialPort] $InputObject,

		[Parameter(Mandatory,
					HelpMessage='This parameter specifies whether to read all immediately available bytes, based on the encoding, in both the stream and the input buffer of the SerialPort object.',
					ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 0,
					ParameterSetName = 'ReadExistingSet')]
		[Switch] $Existing,

		[Parameter(Mandatory,
					HelpMessage='This parameter specifies whether a number of bytes should be read from the SerialPort input buffer.',
					ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 1,
					ParameterSetName = 'ReadSet')]
		[Switch] $NoLine
	)

	Begin
	{
		Write-Verbose -Message ('[{0}] Function started' -f $MyInvocation.MyCommand.Name)
		Write-Verbose -Message ('[{0}] ParameterSetName: {1}' -f $MyInvocation.MyCommand.Name, $PsCmdlet.ParameterSetName)
		Write-Verbose -Message ('[{0}] PSBoundParameters: {1}' -f $MyInvocation.MyCommand.Name, ($PSBoundParameters | Out-String))
	}
	Process
	{
		if ($PsCmdlet.ShouldProcess($InputObject.PortName, $MyInvocation.MyCommand.Name))
		{
			try
			{
				if($PsCmdlet.ParameterSetName -eq 'Default')
				{
					$InputObject.ReadLine()
				}

				if($PsCmdlet.ParameterSetName -eq 'ReadExistingSet')
				{
					$InputObject.ReadExisting()
				}

				if($PsCmdlet.ParameterSetName -eq 'ReadSet')
				{
					[byte[]]$readBuffer = [byte[]]::new($InputObject.ReadBufferSize + 1)
					[int]$count = $InputObject.Read($readBuffer, 0, $InputObject.ReadBufferSize)
					[string]$data = [Text.Encoding]::ASCII.GetString($readBuffer, 0, $count)
					return $data
				}
			}
			catch [TimeoutException]
			{
				Write-Error -Message $Script:LocalizedData.TimeoutExceptionRead
			}
			catch
			{
				Write-Error -Message $_
			}
		}
	}
	End
	{
		Write-Verbose -Message ('[{0}] Function Ended' -f $MyInvocation.MyCommand.Name)
	}
	# .ExternalHelp System.IO.Ports.Commands-help.xml
}

function Wait-DataReceivedEvent
{
	[CmdletBinding(DefaultParameterSetName = 'Default',
					SupportsShouldProcess,
					PositionalBinding = $false,
					HelpUri = 'https://github.com/lmissel/System.IO.Ports.Commands',
					ConfirmImpact = 'Medium')]
	Param
	(
		[Parameter(Mandatory,
					HelpMessage='Represents a serial port resource.',
					ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 0,
					ParameterSetName = 'Default')]
		[ValidateNotNull()]
		[ValidateNotNullOrEmpty()]
		[Alias('SerialPort')]
		[IO.Ports.SerialPort] $InputObject,

		[Parameter(Mandatory,
					HelpMessage='Represents a serial port resource.',
					ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 0,
					ParameterSetName = 'PortNameSet')]
		[ValidateNotNull()]
		[ValidateNotNullOrEmpty()]
		[String] $portName,

		[Parameter(ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 1,
					ParameterSetName = 'Default')]
		[Parameter(ValueFromPipeline,
					ValueFromPipelineByPropertyName,
					ValueFromRemainingArguments = $false,
					Position = 1,
					ParameterSetName = 'PortNameSet')]
		[int] $Timeout = 5,

		[Switch] $Quiet
	)

	Begin
	{
		Write-Verbose -Message ('[{0}] Function started' -f $MyInvocation.MyCommand.Name)
		Write-Verbose -Message ('[{0}] ParameterSetName: {1}' -f $MyInvocation.MyCommand.Name, $PsCmdlet.ParameterSetName)
		Write-Verbose -Message ('[{0}] PSBoundParameters: {1}' -f $MyInvocation.MyCommand.Name, ($PSBoundParameters | Out-String))

		$OldErrorActionPreference = $ErrorActionPreference
		$ErrorActionPreference = [Management.Automation.ActionPreference]::Stop
	}
	Process
	{
		if ($PsCmdlet.ShouldProcess($InputObject.PortName, $MyInvocation.MyCommand.Name))
		{
			try
			{
				if ($PsCmdlet.ParameterSetName -eq 'Default')
				{
					$Name = $InputObject.PortName
				}

				if ($PsCmdlet.ParameterSetName -eq 'PortNameSet')
				{
					$Name = $portName
				}

				# Name of the event subscriber
				$SI1 = 'SerialDataReceivedEventHandler' + $Name

				# Tries to retrieve the event subscriber.
				$null = Get-EventSubscriber -SourceIdentifier $SI1

				# Indicates that data was received through a port represented by the SerialPort object.
				$DataReceivedEvent = Wait-Event -SourceIdentifier $SI1 -Timeout $Timeout

				if (-not($Quiet))
				{
					return $DataReceivedEvent
				}
			}
			catch
			{
				# Create the exception
				$Exception = [Exception]::new($Script:LocalizedData.INVALID_SOURCE_IDENTIFIER -f $Name)
				$Exception.HelpLink = 'https://github.com/lmissel/System.IO.Ports.Commands/'

				# The error which caused the command to be terminated
				$ErrorRecord = [Management.Automation.ErrorRecord]::new($Exception, $_.FullyQualifiedErrorId, [Management.Automation.ErrorCategory]::ObjectNotFound, $SI1)
				$PsCmdlet.ThrowTerminatingError($ErrorRecord)
			}
		}
	}
	End
	{
		$ErrorActionPreference = $OldErrorActionPreference

		Write-Verbose -Message ('[{0}] Function Ended' -f $MyInvocation.MyCommand.Name)
	}
	# .ExternalHelp System.IO.Ports.Commands-help.xml
}