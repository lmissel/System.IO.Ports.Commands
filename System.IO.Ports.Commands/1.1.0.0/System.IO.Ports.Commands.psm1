#
# Module Name: System.IO.MemoryMappedFiles.Commands
# Module Guid: db8afca9-9484-4212-bc58-0989c2050b39
#
# Generated by: lmissel
#
# Generated on: 7/13/2021
#

$Script:LocalizedData = Import-LocalizedData

function Get-SerialPort
{
    [CmdletBinding(DefaultParameterSetName='Default',
                  SupportsShouldProcess=$true,
                  PositionalBinding=$false,
                  HelpUri = 'https://github.com/lmissel/System.IO.Ports.Commands',
                  ConfirmImpact='Medium')]
    [Alias()]
    [OutputType([PSObject[]])]
    Param
    (
        [Parameter(Mandatory=$false,
                   ParameterSetName='Default')]
        [ValidateNotNullOrEmpty()]
        [Switch] $ListAvailable
    )

    Begin
    {
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] Function started"
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] ParameterSetName: $($PsCmdlet.ParameterSetName)"
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] PSBoundParameters: $($PSBoundParameters | Out-String)"
    }
    Process
    {
        if ($pscmdlet.ShouldProcess("SerialPort", $MyInvocation.MyCommand.Name))
        {
            try
            {
                $SerialPortNameCollection = @()

                foreach ($portName in ([System.IO.Ports.SerialPort]::getportnames()))
                {
                    $SerialPortName = New-Object -TypeName PSObject
                    $SerialPortName | Add-Member -MemberType NoteProperty -Name portName -Value $portName

                    $SerialPortNameCollection += $SerialPortName
                }

                return $SerialPortNameCollection
            }
            catch [System.ComponentModel.Win32Exception]
            {
                Write-Error -Message $Script:LocalizedData.Win32Exception
            }
            catch
            {
                Write-Error $_
            }
        }
    }
    End
    {
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] Function Ended"
    }
}

function Open-SerialPort
{
    [CmdletBinding(DefaultParameterSetName='Default',
                  SupportsShouldProcess=$true,
                  PositionalBinding=$false,
                  HelpUri = 'https://github.com/lmissel/System.IO.Ports.Commands',
                  ConfirmImpact='Medium')]
    [Alias()]
    [OutputType([System.IO.Ports.SerialPort])]
    Param
    (
        [Parameter(Mandatory=$true,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=0,
                   ParameterSetName='Default')]
        [ValidateNotNullOrEmpty()]
        [String] $portName,

        [Parameter(Mandatory=$false,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=1,
                   ParameterSetName='Default')]
        [ValidateNotNullOrEmpty()]
        [ValidateRange(1,[int]::MaxValue)]
        [int] $baudRate = 9600,

        [Parameter(Mandatory=$false,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=2,
                   ParameterSetName='Default')]
        [ValidateNotNullOrEmpty()]
        [System.IO.Ports.Parity] $parity = [System.IO.Ports.Parity]::None,

        [Parameter(Mandatory=$false,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=3,
                   ParameterSetName='Default')]
        [ValidateNotNullOrEmpty()]
        [ValidateRange(5,8)]
        [int] $dataBits = 8,

        [Parameter(Mandatory=$false,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=4,
                   ParameterSetName='Default')]
        [ValidateNotNullOrEmpty()]
        [System.IO.Ports.StopBits] $stopBits = [System.IO.Ports.StopBits]::One,

        [Parameter(Mandatory=$false,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=5,
                   ParameterSetName='Default')]
        [ValidateNotNullOrEmpty()]
        [System.IO.Ports.Handshake]$Handshake = [System.IO.Ports.Handshake]"None"
    )

    Begin
    {
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] Function started"
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] ParameterSetName: $($PsCmdlet.ParameterSetName)"
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] PSBoundParameters: $($PSBoundParameters | Out-String)"
    }
    Process
    {
        if ($pscmdlet.ShouldProcess($portName, $MyInvocation.MyCommand.Name))
        {
            try
            {
                [System.IO.Ports.SerialPort] $SerialPort = [System.IO.Ports.SerialPort]::new($portName, $baudRate, $parity, $dataBits, $stopBits)
                $SerialPort.Handshake = $Handshake

                $SerialPort.open();

                Start-Sleep -Milliseconds 1000

                if ($SerialPort.IsOpen) {

                    $SI1 = "SerialDataReceivedEventHandler" + $SerialPort.PortName
                    $SI2 = "SerialErrorReceivedEventHandler" + $SerialPort.PortName
                    $SI3 = "SerialPinChangedEventHandler" + $SerialPort.PortName

                    Write-Verbose ("Register EventHandler [DataReceived] for [{0}]" -f $SerialPort.PortName)
                    Register-ObjectEvent $SerialPort -EventName DataReceived -SourceIdentifier $SI1

                    Write-Verbose ("Register EventHandler [Disposed] for [{0}]" -f $SerialPort.PortName)
                    Register-ObjectEvent $SerialPort -EventName Disposed -SourceIdentifier $SerialPort.PortName

                    Write-Verbose ("Register EventHandler [ErrorReceived] for [{0}]" -f $SerialPort.PortName)
                    Register-ObjectEvent $SerialPort -EventName ErrorReceived -SourceIdentifier $SI2

                    Write-Verbose ("Register EventHandler [PinChanged] for [{0}]" -f $SerialPort.PortName)
                    Register-ObjectEvent $SerialPort -EventName PinChanged -SourceIdentifier $SI3
                }

                return $SerialPort
            }
            catch [System.IO.IOException]
            {
                Write-Error -Message $Script:LocalizedData.IOException
            }
            catch
            {
                Write-Error $_
            }
        }
    }
    End
    {
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] Function Ended"
    }
}

function Close-SerialPort
{
    [CmdletBinding(DefaultParameterSetName='Default',
                  SupportsShouldProcess=$true,
                  PositionalBinding=$false,
                  HelpUri = 'https://github.com/lmissel/System.IO.Ports.Commands',
                  ConfirmImpact='Medium')]
    [Alias()]
    Param
    (
        [Parameter(Mandatory=$true,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=0,
                   ParameterSetName='Default')]
        [Alias('SerialPort')]
        [System.IO.Ports.SerialPort] $InputObject
    )

    Begin
    {
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] Function started"
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] ParameterSetName: $($PsCmdlet.ParameterSetName)"
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] PSBoundParameters: $($PSBoundParameters | Out-String)"
    }
    Process
    {
        if ($pscmdlet.ShouldProcess($InputObject.PortName, $MyInvocation.MyCommand.Name))
        {
            # Checks if an instance of the SerialPort class is present
            if ($InputObject)
            {
                try
                {
                    # Cancels an event subscription.
                    $SI1 = "SerialDataReceivedEventHandler" + $InputObject.PortName
                    $SI2 = "SerialErrorReceivedEventHandler" + $InputObject.PortName
                    $SI3 = "SerialPinChangedEventHandler" + $InputObject.PortName

                    Unregister-Event -SourceIdentifier $SI1
                    Unregister-Event -SourceIdentifier $SI2
                    Unregister-Event -SourceIdentifier $SI3
                    Unregister-Event -SourceIdentifier $InputObject.PortName
                    Write-Verbose -Message ("EventSubscription for [{0}] are unregistered." -f $InputObject.PortName)

                    # Closes the port connection, sets the IsOpen property to false and deletes the internal stream object.
                    Write-Verbose -Message ("Closing SerialPort [{0}]." -f $InputObject.PortName)
                    $SerialPort.Close()

                    # Releases the unmanaged resources used by SerialPort and optionally the managed resources.
                    $SerialPort.Dispose()
                }
                catch
                {
                    Write-Error $_
                }
            }
        }
    }
    End
    {
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] Function Ended"
    }
}

function Write-SerialPort
{
    [CmdletBinding(DefaultParameterSetName='Default',
                  SupportsShouldProcess=$true,
                  PositionalBinding=$false,
                  HelpUri = 'https://github.com/lmissel/System.IO.Ports.Commands',
                  ConfirmImpact='Medium')]
    [Alias()]
    Param
    (
        [Parameter(Mandatory=$true,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=0,
                   ParameterSetName='Default')]
        [Parameter(Mandatory=$true,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=0,
                   ParameterSetName='Write(Byte[], Int32, Int32)')]
        [ValidateNotNull()]
        [ValidateNotNullOrEmpty()]
        [Alias('SerialPort')]
        [System.IO.Ports.SerialPort] $InputObject,

        [Parameter(Mandatory=$true,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=1,
                   ParameterSetName='Default')]
        [ValidateNotNull()]
        [ValidateNotNullOrEmpty()]
        [String] $Text,

        [Parameter(Mandatory=$true,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=1,
                   ParameterSetName='Write(Byte[], Int32, Int32)')]
        [ValidateNotNull()]
        [ValidateNotNullOrEmpty()]
        [byte[]] $Byte,

        [Parameter(Mandatory=$false,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=1,
                   ParameterSetName='Write(Byte[], Int32, Int32)')]
        [ValidateNotNull()]
        [ValidateNotNullOrEmpty()]
        [int] $Offset = 0,

        [Parameter(Mandatory=$false,
                   ValueFromRemainingArguments=$false,
                   Position=2,
                   ParameterSetName='Default')]
        [Switch] $NoNewline
    )

    Begin
    {
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] Function started"
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] ParameterSetName: $($PsCmdlet.ParameterSetName)"
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] PSBoundParameters: $($PSBoundParameters | Out-String)"
    }
    Process
    {
        if ($pscmdlet.ShouldProcess($InputObject.PortName, $MyInvocation.MyCommand.Name))
        {
            try
            {
                if ($pscmdlet.ParameterSetName -eq "Default")
                {
                    if ($NoNewline)
                    {
                        # Writes the specified string to the serial port.
                        $InputObject.Write($text)
                    }
                    else
                    {
                        # Writes the specified string and NewLine value to the output buffer.
                        $InputObject.WriteLine($text)
                    }
                }

                if ($pscmdlet.ParameterSetName -eq "Write(Byte[], Int32, Int32)")
                {
                    $InputObject.Write($Byte, $offset, $Byte.Length)
                }
            }
            catch [System.TimeoutException]
            {
                Write-Error -Message $Script:LocalizedData.TimeoutException
            }
            catch [System.InvalidOperationException]
            {
                Write-Error -Message $Script:LocalizedData.InvalidOperationException
            }
            catch [System.ArgumentNullException]
            {
                Write-Error -Message $Script:LocalizedData.ArgumentNullException
            }
            catch [System.ArgumentOutOfRangeException]
            {
                Write-Error -Message $Script:LocalizedData.ArgumentOutOfRangeException
            }
            catch [System.ArgumentException]
            {
                Write-Error -Message $Script:LocalizedData.ArgumentException
            }
            catch
            {
                Write-Error $_
            }
        }
    }
    End
    {
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] Function Ended"
    }
}

function Read-SerialPort
{
    [CmdletBinding(DefaultParameterSetName='Default',
                  SupportsShouldProcess=$true,
                  PositionalBinding=$false,
                  HelpUri = 'https://github.com/lmissel/System.IO.Ports.Commands',
                  ConfirmImpact='Medium')]
    [Alias()]
    Param
    (
        [Parameter(Mandatory=$true,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=0,
                   ParameterSetName='Default')]
        [Parameter(Mandatory=$true,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=0,
                   ParameterSetName='ReadExistingSet')]
        [Parameter(Mandatory=$true,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=0,
                   ParameterSetName='ReadSet')]
        [Alias('SerialPort')]
        [System.IO.Ports.SerialPort] $InputObject,

        [Parameter(Mandatory=$true,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=0,
                   ParameterSetName='ReadExistingSet')]
        [Switch] $Existing,

        [Parameter(Mandatory=$true,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=1,
                   ParameterSetName='ReadSet')]
        [Switch] $NoLine
    )

    Begin
    {
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] Function started"
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] ParameterSetName: $($PsCmdlet.ParameterSetName)"
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] PSBoundParameters: $($PSBoundParameters | Out-String)"
    }
    Process
    {
        if ($pscmdlet.ShouldProcess($InputObject.PortName, $MyInvocation.MyCommand.Name))
        {
            try
            {
                if($PsCmdlet.ParameterSetName -eq "Default")
                {
                    $InputObject.ReadLine()
                }

                if($PsCmdlet.ParameterSetName -eq "ReadExistingSet")
                {
                    $InputObject.ReadExisting()
                }

                if($PsCmdlet.ParameterSetName -eq "ReadSet")
                {
                    [byte[]]$readBuffer = [byte[]]::new($SerialPort.ReadBufferSize + 1)
                    [int]$count = $InputObject.Read($readBuffer, 0, $SerialPort.ReadBufferSize)
                    [string]$data = [System.Text.Encoding]::ASCII.GetString($readBuffer, 0, $count)
                    return $data
                }
            }
            catch [System.TimeoutException]
            {
                Write-Error -Message $Script:LocalizedData.TimeoutExceptionRead
            }
            catch
            {
                Write-Error $_
            }
        }
    }
    End
    {
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] Function Ended"
    }
}

function Wait-DataReceivedEvent
{
    [CmdletBinding(DefaultParameterSetName='Default',
                  SupportsShouldProcess=$true,
                  PositionalBinding=$false,
                  HelpUri = 'https://github.com/lmissel/System.IO.Ports.Commands',
                  ConfirmImpact='Medium')]
    [Alias()]
    Param
    (
        [Parameter(Mandatory=$true,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=0,
                   ParameterSetName='Default')]
        [ValidateNotNull()]
        [ValidateNotNullOrEmpty()]
        [Alias('SerialPort')]
        [System.IO.Ports.SerialPort] $InputObject,

        [Parameter(Mandatory=$true,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=0,
                   ParameterSetName='PortNameSet')]
        [ValidateNotNull()]
        [ValidateNotNullOrEmpty()]
        [String] $PortName,

        [Parameter(Mandatory=$false,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=1,
                   ParameterSetName='Default')]
        [Parameter(Mandatory=$false,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ValueFromRemainingArguments=$false,
                   Position=1,
                   ParameterSetName='PortNameSet')]
        [int] $Timeout = 5,

        [Switch] $Quiet
    )

    Begin
    {
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] Function started"
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] ParameterSetName: $($PsCmdlet.ParameterSetName)"
        Write-Verbose "[$($MyInvocation.MyCommand.Name)] PSBoundParameters: $($PSBoundParameters | Out-String)"

        $OldErrorActionPreference = $ErrorActionPreference
        $ErrorActionPreference = [System.Management.Automation.ActionPreference]::Stop
    }
    Process
    {
        if ($pscmdlet.ShouldProcess($InputObject.PortName, $MyInvocation.MyCommand.Name))
        {
            try
            {
                if ($PsCmdlet.ParameterSetName -eq 'Default')
                {
                    $Name = $InputObject.PortName
                }

                if ($PsCmdlet.ParameterSetName -eq 'PortNameSet')
                {
                    $Name = $PortName
                }

                # Name of the event subscriber
                $SI1 = "SerialDataReceivedEventHandler" + $Name

                # Tries to retrieve the event subscriber.
                $null = Get-EventSubscriber -SourceIdentifier $SI1

                # Indicates that data was received through a port represented by the SerialPort object.
                $DataReceivedEvent = Wait-Event -SourceIdentifier $SI1 -Timeout $Timeout

                if (-not($Quiet))
                {
                    return $DataReceivedEvent
                }
            }
            catch
            {
                # Create the exception
                $Exception = [Exception]::new($Script:LocalizedData.INVALID_SOURCE_IDENTIFIER -f $Name)
                $Exception.HelpLink = "https://github.com/lmissel/System.IO.Ports.Commands/"

                # The error which caused the command to be terminated
                $ErrorRecord = [System.Management.Automation.ErrorRecord]::new($Exception, $_.FullyQualifiedErrorId, [System.Management.Automation.ErrorCategory]::ObjectNotFound, $SI1)
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)
            }
        }
    }
    End
    {
        $ErrorActionPreference = $OldErrorActionPreference

        Write-Verbose "[$($MyInvocation.MyCommand.Name)] Function Ended"
    }
}